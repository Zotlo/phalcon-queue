<?php

namespace Phalcon\Queue;

final class Channel
{
    /** @var array $channels */
    private static array $channels = [];

    /** @var string $id */
    private string $id;

    /** @var int MAX_MESSAGE_SIZE */
    private const MAX_MESSAGE_SIZE = 131072;

    public function __construct()
    {
        $this->id = strtoupper(uniqid());
    }

    /**
     * Create a Channel object.
     *
     * @return self
     */
    public static function make(): self
    {
        return new Channel();
    }

    /**
     * Creates a specified number of Channel objects and stores them.
     *
     * @param int $size
     * @return array<self>
     */
    public static function makes(int $size): array
    {
        for ($i = 0; $i < $size; $i++) {
            self::$channels[] = self::make();
        }

        return self::$channels;
    }

    /**
     * Reads a single message from the queue.
     *
     * If there is no message available within the timeout period, it will return `null`.
     *
     * @param int $timeout The maximum time (in seconds) to wait for a message (default: 15).
     * @return string|null The message as a string if found; otherwise, `null`.
     */
    public function read(int $timeout = 15): ?string
    {
        $ts = microtime(true);
        $q = msg_get_queue($this->key());

        while (microtime(true) - $ts < $timeout) {
            if (@msg_receive($q, 1, $type, self::MAX_MESSAGE_SIZE, $message, true, MSG_IPC_NOWAIT)) {
                break;
            }
            usleep(100000);
        }

        if (isset($message) && is_string($message)) {
            return $message;
        }

        return null;
    }

    /**
     * Reads all available messages from the queue within the timeout period.
     *
     * The method continuously reads messages until the timeout period expires or no more messages are available.
     *
     * @param int $timeout The maximum time (in seconds) to wait for messages (default: 15).
     * @return array<string> An array of messages read from the queue. If no messages are available, returns an empty array.
     */
    public function readAll(int $timeout = 15): array
    {
        $ts = microtime(true);
        $q = msg_get_queue($this->key());
        $messages = [];

        while (microtime(true) - $ts < $timeout) {
            if (@msg_receive($q, 1, $type, self::MAX_MESSAGE_SIZE, $message, true, MSG_IPC_NOWAIT)) {
                $messages[] = $message;
            } else {
                usleep(100000);
            }
        }

        return $messages;
    }

    /**
     * Writes a message to the queue.
     *
     * This method sends a message to the queue using the `msg_send` function.
     * It returns `true` if the message is successfully sent, otherwise `false`.
     *
     * @param string $message The message to be written to the queue.
     * @return bool `true` if the message is successfully written; otherwise, `false`.
     */
    public function write(string $message): bool
    {
        $q = msg_get_queue($this->key());
        return msg_send($q, 1, $message);
    }

    /**
     * Generates a unique key for the current channel.
     *
     * The key is generated by hashing the channel ID using the MD5 algorithm,
     * extracting the first 8 characters of the hash, and converting it to a decimal value.
     *
     * @return int The unique key for the channel as a decimal integer.
     */
    private function key(): int
    {
        return hexdec(substr(md5($this->id), 0, 8));
    }
}